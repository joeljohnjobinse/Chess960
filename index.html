<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>chess960</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css"/>
<style>
:root{
  --board:560px; --bg:#06070a; --panel:#0e1216; --text:#fff; --muted:#9aa4b2;
  --blue:#3aa0ff; --blue2:#6bb9ff; --grey-dark:#444; --green:#2ecc71; --purple:#9b59b6;
}
*{ box-sizing:border-box; }
body{ margin:0; background:var(--bg); color:var(--text); font-family:Bahnschrift,"Segoe UI",Roboto,Arial,sans-serif; display:flex; flex-direction:column; min-height:100vh; }
header{ padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.06); display:flex; gap:12px; align-items:center; }
header .brand{ font-weight:800; font-size:18px; }
main{ flex:1; max-width:1200px; margin:0 auto; padding:20px; display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; justify-content:center; }

.left{ display:flex; align-items:flex-start; gap:12px; margin:0 auto; }
.eval{ width:26px; height:var(--board); position:relative; background:var(--grey-dark); border-radius:10px; box-shadow: inset 0 0 26px rgba(0,0,0,.6); overflow:hidden; }
.eval .whiteFill{ position:absolute; left:0; right:0; height:50%; background:#fff; transition: height .35s ease, top .35s ease, bottom .35s ease; top:50%; }
.eval .thumb{ position:absolute; left:-4px; right:-4px; height:2px; background: var(--blue); transition: top .35s ease, bottom .35s ease; top:50%; }
.boardWrap{ background: var(--panel); padding:14px; border-radius:12px; box-shadow: 0 8px 28px rgba(0,0,0,.65); }
#board{ width: var(--board); height: var(--board); }
#game-status{ text-align:center; margin-top:8px; color:var(--muted); font-weight:700; }
#flipBtn { grid-column: 1; }
#undoBtn { grid-column: 2; }
#multiplayerBtn { grid-column: 1 / span 3; }


.controls{ margin-top:12px; display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
.controls-top-row{ grid-column:1 / span 3; display:flex; gap:8px; justify-content:center; }
button{ font-family:Bahnschrift,"Segoe UI",Roboto,Arial,sans-serif; font-weight:700; font-size:15px; padding:10px 14px; border-radius:10px; border:none; color:#fff; background: linear-gradient(180deg, var(--blue), var(--blue2)); cursor:pointer; box-shadow:0 10px 20px rgba(58,160,255,.18); transition: transform .06s ease, filter .15s ease; width:100%; }
button:hover{ filter: brightness(1.07); }
button:active{ transform: translateY(1px); }
.btn-secondary{ background: transparent; color: var(--muted); border:1px solid rgba(255,255,255,.08); box-shadow:none; }
.btn-success { background: linear-gradient(180deg, var(--green), #27ae60); box-shadow: 0 10px 20px rgba(46, 204, 113, 0.18); }
.btn-purple { background: linear-gradient(180deg, var(--purple), #8e44ad); box-shadow: 0 10px 20px rgba(155, 89, 182, 0.18); }

.engineBox{ margin-top:10px; background:rgba(10,12,15,.95); border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:10px 12px; min-width:260px; display:none; }
.engineBox.visible{ display:block; }
.engineTitle{ font-weight:800; margin-bottom:6px; }
#engineEval,#engineMove{ color:var(--muted); font-size:14px; margin-top:6px; white-space:pre-wrap; }

.right{ flex:1; min-width:320px; display:flex; flex-direction:column; gap:12px; }
.panel{ background:var(--panel); border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,.6); }
.moves{ max-height: calc(var(--board) * .6); overflow:auto; padding:8px; }
.moves ol{ margin:0; padding-left:0; color:var(--muted); list-style-type:none; }
.moves li { display: flex; padding: 4px 0; }
.move-number { min-width: 30px; color: var(--muted); }
.white-move, .black-move { flex: 1; padding: 0 5px; }
.white-move { color: var(--text); }
.black-move { color: var(--muted); }

textarea{ width:100%; min-height:110px; border-radius:8px; border:1px solid rgba(255,255,255,.06); background: rgba(255,255,255,0.03); color:var(--text); padding:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; resize:vertical; }
.copyBtn{ margin-top:8px; width:120px; }
.status-dot{ width:10px; height:10px; border-radius:50%; background:var(--muted); display:inline-block; margin-right:8px; vertical-align:middle; }
.status-dot.connected{ background:var(--green); }

.game-over-controls { display:none; justify-content: center; gap: 10px; margin-top: 10px; }
.game-over-controls.visible { display:flex; }
.game-over-controls button { flex: 1; }

@media (max-width:1080px){ :root{ --board:420px; } .controls { grid-template-columns: repeat(2, 1fr); } .controls-top-row { grid-column: 1 / span 2; } }
@media (max-width:480px){ :root{ --board:420px; } .controls { grid-template-columns: 1fr; } .controls-top-row { grid-column: 1; flex-direction: column; } .left { flex-direction: column; align-items:center; } .eval { width: var(--board); height: 26px; order: 1; } .eval .whiteFill { width: 50%; height: 100%; bottom: auto; top: 0; } .eval .thumb { width: 2px; height: 100%; left:50%; transform: translateX(-50%); bottom:auto; } }
</style>
</head>
<body>
<header>
  <div class="brand">chess960</div>
  <div style="color:var(--muted); margin-left:8px;">Manual SDP WebRTC + Stockfish</div>
</header>

<main>
  <div class="left">
    <div class="eval" id="evalBar">
      <div class="whiteFill" id="evalWhite"></div>
      <div class="thumb" id="evalThumb"></div>
    </div>

    <div class="boardWrap">
      <div id="board"></div>
      <div id="game-status">White to move</div>

      <div class="controls">
        <div class="controls-top-row">
          <button id="newGameBtn">New Random</button>
          <button class="btn-secondary" id="standardBtn">Standard</button>
        </div>
        <button class="btn-secondary" id="flipBtn">Flip Board</button>
        <button class="btn-secondary" id="undoBtn">Undo Move</button>
        <button class="btn-purple" id="multiplayerBtn">Multiplayer</button>
      </div>

      <div id="gameOverControls" class="game-over-controls">
        <button id="newGameAfterBtn">New Game</button>
      </div>
    </div>
  </div>

  <aside class="right">
    <div class="engineBox panel" id="engineBox">
      <div class="engineTitle">Engine Analysis</div>
      <div id="engineEval">Eval: --</div>
      <div id="engineMove">Best Move: --</div>
    </div>

    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <strong>Move list</strong>
      </div>
      <div class="moves"><ol id="moveList"></ol></div>
    </div>

    <div class="panel multiplayer-panel" id="multiplayerPanel" style="display:none;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <strong>Multiplayer (WebRTC)</strong>
        <div style="display:flex;align-items:center">
          <span class="status-dot" id="connectionDot"></span>
          <span id="connectionStatusText" style="color:var(--muted);margin-left:6px;">Idle</span>
        </div>
      </div>

      <div style="display:grid;gap:8px;">
        <div>
          <button id="hostBtn" class="btn-success">Host (Create Offer) — You will be White</button>
          <button id="joinBtn" class="btn-secondary" style="margin-left:8px">Join (Paste Offer) — You will be Black</button>
        </div>

        <div>
          <label style="font-weight:700">Local SDP (copy & share)</label>
          <textarea id="localSdp" placeholder="Local SDP will appear here when created"></textarea>
          <button id="copyLocalSdpBtn" class="copyBtn btn-secondary">Copy Local SDP</button>
        </div>

        <div>
          <label style="font-weight:700">Remote SDP (paste here)</label>
          <textarea id="remoteSdp" placeholder="Paste the remote SDP here (offer or answer)"></textarea>
          <button id="applyRemoteBtn" class="copyBtn btn-secondary">Apply Remote SDP</button>
        </div>

        <div style="color:var(--muted); font-size:13px;">
          Exchange the SDP (copy/paste) with your opponent. Host creates an offer and shares Local SDP. Joiner pastes Host SDP into Remote box and clicks "Apply Remote SDP" — Joiner’s Local SDP (answer) will then appear to copy back to Host. Host pastes the answer into his Remote box and applies it.
        </div>
      </div>
    </div>
  </aside>
</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

<script>
const game = new Chess();
let board = null;
let orientation = 'white';
let fenHistory = [];
let moveHistory = [];
let isGameOver = false;

let pc = null;
let dc = null;
let myColor = 'w';
let isRtcConnected = false;

const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:stun2.l.google.com:19302' },
  { urls: 'stun:stun3.l.google.com:19302' },
  { urls: 'stun:stun4.l.google.com:19302' },
  { urls: 'stun:stun.services.mozilla.com:3478' },
  { urls: 'stun:stun.stunprotocol.org:3478' },
  { urls: 'stun:bn-turn2.xirsys.com' },
  {
    username: "sZz53mb_N1HrDxkJKDUL4EXjSv96Y6aPbzZgnkzv2BjJC-_d0BKTpz-9hLCIqFV2AAAAAGiljFBqb2Vsam9iaW5zZQ==",
    credential: "b637d73c-7da2-11f0-989d-0242ac140004",
    urls: [
      "turn:bn-turn2.xirsys.com:80?transport=udp",
      "turn:bn-turn2.xirsys.com:3478?transport=udp",
      "turn:bn-turn2.xirsys.com:80?transport=tcp",
      "turn:bn-turn2.xirsys.com:3478?transport=tcp",
      "turns:bn-turn2.xirsys.com:443?transport=tcp",
      "turns:bn-turn2.xirsys.com:5349?transport=tcp"
    ]
  }
];

function setRtcStatus(txt, connected=false){
  $('#connectionStatusText').text(txt);
  $('#connectionDot').toggleClass('connected', connected);
}

function generateChess960Position() {
  const pieces = Array(8).fill(null);
  const dark = [0,2,4,6], light=[1,3,5,7];
  const b1 = dark[Math.floor(Math.random()*dark.length)];
  const b2 = light[Math.floor(Math.random()*light.length)];
  pieces[b1] = 'B'; pieces[b2] = 'B';
  let empties = []; for (let i=0;i<8;i++) if (!pieces[i]) empties.push(i);
  const q = empties.splice(Math.floor(Math.random()*empties.length),1)[0]; pieces[q]='Q';
  const n1 = empties.splice(Math.floor(Math.random()*empties.length),1)[0];
  const n2 = empties.splice(Math.floor(Math.random()*empties.length),1)[0];
  pieces[n1]='N'; pieces[n2]='N';
  empties.sort((a,b)=>a-b);
  pieces[empties[0]]='R'; pieces[empties[1]]='K'; pieces[empties[2]]='R';
  const whiteBack = pieces.join(''), blackBack = pieces.map(p=>p.toLowerCase()).join('');
  return `${blackBack}/pppppppp/8/8/8/8/PPPPPPPP/${whiteBack} w - - 0 1`;
}

function updateStatus(){
  const turn = game.turn()==='w'?'White':'Black';
  let txt = '';
  if (game.in_checkmate()){
    txt = `Game over, ${turn} is in checkmate!`;
    isGameOver = true;
    $('#gameOverControls').addClass('visible');
  } else if (game.in_draw()){
    txt = 'Game over, drawn position';
    isGameOver = true;
    $('#gameOverControls').addClass('visible');
  } else {
    txt = `${turn} to move`;
    if (game.in_check()) txt += `, ${turn} is in check`;
    isGameOver = false;
    $('#gameOverControls').removeClass('visible');
  }
  $('#game-status').text(txt);
}

function refreshMoves(){
  const ol = document.getElementById('moveList');
  ol.innerHTML = '';
  for (let i=0;i<moveHistory.length;i+=2){
    const num = Math.floor(i/2)+1;
    const w = moveHistory[i]||'', b = moveHistory[i+1]||'';
    const li = document.createElement('li');
    li.innerHTML = `<span class="move-number">${num}.</span> <span class="white-move">${w}</span> <span class="black-move">${b}</span>`;
    ol.appendChild(li);
  }
  ol.scrollTop = ol.scrollHeight;
}

function refreshUI(){
  updateStatus();
  refreshMoves();
}
  
let engine = null;
let engineReady = false;
let pendingFen = null;
let lastAnalyzedFen = null;

function initEngine() {
  try {
    const workerCode = `
      importScripts('https://cdn.jsdelivr.net/npm/stockfish.js@10.0.2/stockfish.js');
      self.postMessage('Stockfish loaded successfully');
    `;
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    engine = new Worker(URL.createObjectURL(blob));
    
    engine.onmessage = function(e) {
      const line = e.data;

      if (!line || typeof line !== 'string') return;

      // early message from worker wrapper
      if (line.includes('Stockfish')) {
        console.log(line);
        return;
      }
      if (line.includes('readyok')) {
        engineReady = true;
        if (pendingFen) {
          const f = pendingFen;
          pendingFen = null;
          runEngine(f);
        }
        return;
      }

      if (line.startsWith('info ')) {
        const parts = line.split(/\s+/);
        const scoreIdx = parts.indexOf('score');
        if (scoreIdx !== -1) {
          const kind = parts[scoreIdx+1];
          const raw = parts[scoreIdx+2];
          if (kind === 'cp') {
            const cp = parseInt(raw, 10);
            $('#engineEval').text('Eval: ' + (cp>=0?'+':'') + (cp/100).toFixed(2));
            setEvalByCp(cp);
          } else if (kind === 'mate') {
            const mate = parseInt(raw, 10);
            $('#engineEval').text('Eval: mate ' + mate);
            setEvalByCp(mate > 0 ? 1000 : -1000);
          }
        }
      }

      if (line.startsWith('bestmove')) {
        const parts = line.split(/\s+/);
        const bestuci = parts[1] || '';
        const san = uciToSan(bestuci, lastAnalyzedFen);
        $('#engineMove').text('Best Move: ' + (san || bestuci || '—'));
        $('#engineBox').addClass('visible');
      }
    };

    engine.postMessage('uci');
    engine.postMessage('isready');
    engine.postMessage('setoption name Threads value 2');
    engine.postMessage('setoption name Hash value 64');

  } catch(err) {
    console.error('Failed to initialize Stockfish:', err);
    engineReady = false;
  }
}

function runEngine(fen) {
  if (!engine) initEngine();

  if (!engineReady) {
    pendingFen = fen;
    return;
  }

  lastAnalyzedFen = fen;
  document.getElementById('engineBox').classList.add('visible');
  engine.postMessage('ucinewgame');
  engine.postMessage('position fen ' + fen);
  engine.postMessage('go depth 15');
}

function uciToSan(uci, fen) {
  if (!uci || !fen) return uci || '';
  const from = uci.substring(0,2);
  const to = uci.substring(2,4);
  const prom = uci.length>4 ? uci[4] : undefined;
  const tmp = new Chess(fen);
  try {
    const m = tmp.move({ from, to, promotion: (prom || 'q') });
    if (m) return m.san;
  } catch(e){}
  return uci;
}

function setEvalByCp(cp) {
  const capped = Math.max(-800, Math.min(800, cp));
  const pct = 50 + (capped / 16);
  const percent = Math.max(0, Math.min(100, pct));
  const whiteFill = document.getElementById('evalWhite');
  const thumb = document.getElementById('evalThumb');
  whiteFill.style.height = percent + '%';
  whiteFill.style.top = (100 - percent) + '%';
  thumb.style.top = (100 - percent) + '%';
}

function initBoard(){
  board = Chessboard('board', {
    draggable: true,
    position: 'start',
    orientation: orientation,
    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',

    onDragStart: function(source, piece){
      if (game.game_over()) return false;
      const pieceColor = piece.charAt(0); // 'w' or 'b'
      const rtcActive = !!(dc && dc.readyState === 'open');
      if (rtcActive) {
        if ((game.turn() === 'w' && myColor !== 'w') || (game.turn() === 'b' && myColor !== 'b')) return false;
        if ((myColor === 'w' && pieceColor !== 'w') || (myColor === 'b' && pieceColor !== 'b')) return false;
      }
    },

    onDrop: function(source, target){
      const mv = game.move({ from: source, to: target, promotion: 'q' });
      if (!mv) return 'snapback';

      fenHistory.push(game.fen());
      moveHistory.push(mv.san);
      refreshUI();
      board.position(game.fen(), false);

      if (dc && dc.readyState === 'open') {
        rtcSend({ type:'move', fen: game.fen(), san: mv.san, moveHistory: moveHistory.slice() });
      }

      runEngine(game.fen());
    },

    onSnapEnd: function(){
      board.position(game.fen(), false);
    }
  });
}

function newChess960Game(){
  const fen = generateChess960Position();
  game.load(fen);
  board.position(fen);
  fenHistory = [fen];
  moveHistory = [];
  refreshUI();
  runEngine(fen);
  if (dc && dc.readyState === 'open') rtcSend({ type:'newGame', fen });
}

function updateLocalSdpTextarea(){
  try {
    if (pc && pc.localDescription) {
      $('#localSdp').val(JSON.stringify(pc.localDescription));
    }
  } catch(e){ console.warn('updateLocalSdpTextarea', e); }
}

async function createPeer(initiator=false){
  myColor = initiator ? 'w' : 'b';
  orientation = (myColor === 'w') ? 'white' : 'black';
  if (board && typeof board.orientation === 'function') board.orientation(orientation);

  if (pc) { try { pc.close(); } catch(_){} }
  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.onicecandidate = (event) => {
    updateLocalSdpTextarea();
  };

  pc.onicegatheringstatechange = () => {
    if (pc.iceGatheringState === 'complete') updateLocalSdpTextarea();
  };

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'connected') {
      isRtcConnected = true;
      setRtcStatus('Connected', true);
    } else if (['disconnected','failed','closed'].includes(pc.connectionState)) {
      isRtcConnected = false;
      setRtcStatus('Not connected', false);
    } else {
      setRtcStatus(pc.connectionState, false);
    }
  };

  pc.oniceconnectionstatechange = () => {
    console.log('ICE connection state:', pc.iceConnectionState);
  };

  if (initiator) {
    dc = pc.createDataChannel('chess960');
    wireDataChannel(dc);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    setRtcStatus('Offer created — gathering ICE', false);
  } else {
    pc.ondatachannel = (ev) => {
      dc = ev.channel; wireDataChannel(dc);
      setRtcStatus('DataChannel created (joiner)', false);
    };
    setRtcStatus('Ready to accept offer — you are Black', false);
  }
}

function wireDataChannel(channel){
  channel.onopen = () => {
    setRtcStatus('Connected', true);
    setTimeout(()=> rtcSend({ type:'syncRequest' }), 300);
  };
  channel.onclose = () => { setRtcStatus('Not connected', false); };
  channel.onmessage = (ev) => {
    try { handleRtcMessage(JSON.parse(ev.data)); }
    catch(e){ console.warn('Bad RTC msg', e); }
  };
}

function rtcSend(obj){
  if (dc && dc.readyState === 'open') {
    try { dc.send(JSON.stringify(obj)); } catch(e){ console.warn('rtcSend fail', e); }
  }
}

async function applyRemoteSdp(){
  const raw = $('#remoteSdp').val().trim();
  if (!raw) { alert('Paste remote SDP JSON first'); return; }
  let desc;
  try { desc = JSON.parse(raw); } catch(e){ alert('Invalid JSON'); return; }

  try {
    if (desc.type === 'offer') {
      await pc.setRemoteDescription(desc);
      setRtcStatus('Remote offer applied — creating answer', false);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      setTimeout(()=> { try { $('#localSdp').val(JSON.stringify(pc.localDescription)); } catch(e){} }, 400);
    } else if (desc.type === 'answer') {
      await pc.setRemoteDescription(desc);
      setRtcStatus('Remote answer applied', false);
    } else {
      await pc.setRemoteDescription(desc);
      setRtcStatus('Remote SDP applied', false);
    }
  } catch(e){
    console.error('applyRemoteSdp', e);
    alert('Failed to apply remote SDP — check console for details');
  }
}

function handleRtcMessage(msg){
  if (!msg || typeof msg.type !== 'string') return;

  if (msg.type === 'syncRequest') {
    rtcSend({ type:'syncState', fen: game.fen(), moveHistory: moveHistory.slice() });
    return;
  }

  if (msg.type === 'syncState' && msg.fen) {
    try {
      game.load(msg.fen);
      board.position(msg.fen(), false);
      moveHistory = Array.isArray(msg.moveHistory) ? msg.moveHistory.slice() : [];
      fenHistory = [msg.fen];
      refreshUI();
      runEngine(msg.fen());
    } catch(e){ console.warn('syncState apply error', e); }
    return;
  }

  if (msg.type === 'newGame' && msg.fen) {
    try {
      game.load(msg.fen);
      board.position(msg.fen(), false);
      moveHistory = [];
      fenHistory = [msg.fen];
      refreshUI();
      runEngine(msg.fen());
    } catch(e){}
    return;
  }

  if (msg.type === 'move' && msg.fen && msg.san) {
    try {
      game.load(msg.fen);
      board.position(msg.fen(), false);
      moveHistory = Array.isArray(msg.moveHistory) ? msg.moveHistory.slice() : (moveHistory.concat(msg.san));
      fenHistory.push(msg.fen);
      refreshUI();
      runEngine(msg.fen());
    } catch(e){ console.warn('apply move fail', e); }
  }
}

$(document).ready(function(){
  initBoard();
  initEngine();
  newChess960Game();
});

$('#newGameBtn').on('click', newChess960Game);

$('#standardBtn').on('click', function(){
  const fenStd = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
  game.load(fenStd);
  board.position('start');
  fenHistory=[fenStd];
  moveHistory=[];
  refreshUI();
  runEngine(fenStd);
});

$('#flipBtn').on('click', function(){
  orientation = (orientation === 'white' ? 'black' : 'white');
  board.flip();
});

$('#undoBtn').on('click', function(){
  if (dc && dc.readyState === 'open') { alert('Undo is disabled in multiplayer'); return; }
  const m = game.undo();
  if (!m) return;
  moveHistory.pop();
  board.position(game.fen(), false);
  refreshUI();
  runEngine(game.fen());
});

$('#newGameAfterBtn').on('click', newChess960Game);

$('#multiplayerBtn').on('click', function(){ $('#multiplayerPanel').toggle(); });

$('#hostBtn').on('click', async function(){
  await createPeer(true);
  $('#localSdp').val('Gathering ICE… waiting for ICE candidates to complete. Copy the Local SDP when ICE gathering finishes (or copy intermediate states if you prefer).');
  setRtcStatus('Offer created — waiting for ICE', false);
});

$('#joinBtn').on('click', async function(){
  await createPeer(false);
  $('#localSdp').val('Paste host offer into Remote SDP box then click Apply Remote SDP. Your answer will appear here after ICE gathering.');
  setRtcStatus('Ready to accept offer — you are Black', false);
});

$('#applyRemoteBtn').on('click', async function(){
  await applyRemoteSdp();
  setTimeout(()=> { try { $('#localSdp').val(JSON.stringify(pc.localDescription)); } catch(e){} }, 400);
});

$('#copyLocalSdpBtn').on('click', function(){
  const txt = $('#localSdp').val();
  if (!txt) return alert('Nothing to copy');
  navigator.clipboard.writeText(txt).then(()=> {
    $(this).text('Copied!');
    setTimeout(()=> $(this).text('Copy Local SDP'), 1200);
  }).catch(()=> alert('Copy failed — copy manually'));
});

window.addEventListener('beforeunload', ()=>{ try{ dc && dc.close && dc.close(); pc && pc.close && pc.close(); }catch(e){} });
</script>
</body>
</html>

